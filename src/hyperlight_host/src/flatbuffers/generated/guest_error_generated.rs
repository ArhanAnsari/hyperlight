// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod hyperlight {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod generated {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_ERROR_CODE: u64 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_ERROR_CODE: u64 = 16;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_ERROR_CODE: [ErrorCode; 16] = [
            ErrorCode::NoError,
            ErrorCode::UnsupportedParameterType,
            ErrorCode::GuestFunctionNameNotProvided,
            ErrorCode::GuestFunctionNotFound,
            ErrorCode::GuestFunctionIncorrecNoOfParameters,
            ErrorCode::GispatchFunctionPointerNotSet,
            ErrorCode::OutbError,
            ErrorCode::UnknownError,
            ErrorCode::StackOverflow,
            ErrorCode::GsCheckFailed,
            ErrorCode::TooManyGuestFunctions,
            ErrorCode::FailureInDlmalloc,
            ErrorCode::MallocFailed,
            ErrorCode::GuestFunctionParameterTypeMismatch,
            ErrorCode::GuestError,
            ErrorCode::ArrayLengthParamIsMissing,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct ErrorCode(pub u64);
        #[allow(non_upper_case_globals)]
        impl ErrorCode {
            pub const NoError: Self = Self(0);
            pub const UnsupportedParameterType: Self = Self(2);
            pub const GuestFunctionNameNotProvided: Self = Self(3);
            pub const GuestFunctionNotFound: Self = Self(4);
            pub const GuestFunctionIncorrecNoOfParameters: Self = Self(5);
            pub const GispatchFunctionPointerNotSet: Self = Self(6);
            pub const OutbError: Self = Self(7);
            pub const UnknownError: Self = Self(8);
            pub const StackOverflow: Self = Self(9);
            pub const GsCheckFailed: Self = Self(10);
            pub const TooManyGuestFunctions: Self = Self(11);
            pub const FailureInDlmalloc: Self = Self(12);
            pub const MallocFailed: Self = Self(13);
            pub const GuestFunctionParameterTypeMismatch: Self = Self(14);
            pub const GuestError: Self = Self(15);
            pub const ArrayLengthParamIsMissing: Self = Self(16);

            pub const ENUM_MIN: u64 = 0;
            pub const ENUM_MAX: u64 = 16;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NoError,
                Self::UnsupportedParameterType,
                Self::GuestFunctionNameNotProvided,
                Self::GuestFunctionNotFound,
                Self::GuestFunctionIncorrecNoOfParameters,
                Self::GispatchFunctionPointerNotSet,
                Self::OutbError,
                Self::UnknownError,
                Self::StackOverflow,
                Self::GsCheckFailed,
                Self::TooManyGuestFunctions,
                Self::FailureInDlmalloc,
                Self::MallocFailed,
                Self::GuestFunctionParameterTypeMismatch,
                Self::GuestError,
                Self::ArrayLengthParamIsMissing,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NoError => Some("NoError"),
                    Self::UnsupportedParameterType => Some("UnsupportedParameterType"),
                    Self::GuestFunctionNameNotProvided => Some("GuestFunctionNameNotProvided"),
                    Self::GuestFunctionNotFound => Some("GuestFunctionNotFound"),
                    Self::GuestFunctionIncorrecNoOfParameters => {
                        Some("GuestFunctionIncorrecNoOfParameters")
                    }
                    Self::GispatchFunctionPointerNotSet => Some("GispatchFunctionPointerNotSet"),
                    Self::OutbError => Some("OutbError"),
                    Self::UnknownError => Some("UnknownError"),
                    Self::StackOverflow => Some("StackOverflow"),
                    Self::GsCheckFailed => Some("GsCheckFailed"),
                    Self::TooManyGuestFunctions => Some("TooManyGuestFunctions"),
                    Self::FailureInDlmalloc => Some("FailureInDlmalloc"),
                    Self::MallocFailed => Some("MallocFailed"),
                    Self::GuestFunctionParameterTypeMismatch => {
                        Some("GuestFunctionParameterTypeMismatch")
                    }
                    Self::GuestError => Some("GuestError"),
                    Self::ArrayLengthParamIsMissing => Some("ArrayLengthParamIsMissing"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for ErrorCode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for ErrorCode {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<u64>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for ErrorCode {
            type Output = ErrorCode;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<u64>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for ErrorCode {
            type Scalar = u64;
            #[inline]
            fn to_little_endian(self) -> u64 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u64) -> Self {
                let b = u64::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for ErrorCode {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u64::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for ErrorCode {}
        pub enum GuestErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GuestError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GuestError<'a> {
            type Inner = GuestError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GuestError<'a> {
            pub const VT_CODE: flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GuestError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GuestErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<GuestError<'bldr>> {
                let mut builder = GuestErrorBuilder::new(_fbb);
                builder.add_code(args.code);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn code(&self) -> ErrorCode {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<ErrorCode>(GuestError::VT_CODE, Some(ErrorCode::NoError))
                        .unwrap()
                }
            }
            #[inline]
            pub fn message(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(GuestError::VT_MESSAGE, None)
                }
            }
        }

        impl flatbuffers::Verifiable for GuestError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<ErrorCode>("code", Self::VT_CODE, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct GuestErrorArgs<'a> {
            pub code: ErrorCode,
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for GuestErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                GuestErrorArgs {
                    code: ErrorCode::NoError,
                    message: None,
                }
            }
        }

        pub struct GuestErrorBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GuestErrorBuilder<'a, 'b> {
            #[inline]
            pub fn add_code(&mut self, code: ErrorCode) {
                self.fbb_
                    .push_slot::<ErrorCode>(GuestError::VT_CODE, code, ErrorCode::NoError);
            }
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(GuestError::VT_MESSAGE, message);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GuestErrorBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GuestErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GuestError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GuestError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GuestError");
                ds.field("code", &self.code());
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `GuestError`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_guest_error_unchecked`.
        pub fn root_as_guest_error(
            buf: &[u8],
        ) -> Result<GuestError, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<GuestError>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `GuestError` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_guest_error_unchecked`.
        pub fn size_prefixed_root_as_guest_error(
            buf: &[u8],
        ) -> Result<GuestError, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<GuestError>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `GuestError` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_guest_error_unchecked`.
        pub fn root_as_guest_error_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<GuestError<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<GuestError<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `GuestError` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_guest_error_unchecked`.
        pub fn size_prefixed_root_as_guest_error_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<GuestError<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<GuestError<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a GuestError and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `GuestError`.
        pub unsafe fn root_as_guest_error_unchecked(buf: &[u8]) -> GuestError {
            flatbuffers::root_unchecked::<GuestError>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed GuestError and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `GuestError`.
        pub unsafe fn size_prefixed_root_as_guest_error_unchecked(buf: &[u8]) -> GuestError {
            flatbuffers::size_prefixed_root_unchecked::<GuestError>(buf)
        }
        #[inline]
        pub fn finish_guest_error_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<GuestError<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_guest_error_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<GuestError<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Generated
} // pub mod Hyperlight
