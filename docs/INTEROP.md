# Notes on C# <--> Rust interop

This document contains notes and learnings on how to get C# and Rust to play well together. Since we primarily call Rust from C# in this codebase, the notes here mostly cover that task, rather than calling C# from Rust or anything else.

## General

Generally speaking, C# code cannot directly call a Rust function. Instead, it has to call a C function interface, and Rust has to implement that C function interface. In practice, the effect is the same.

In this document, you'll see lots of mentions of C# calling, or passing data to, C, and Rust consuming or receiving data from C. This nomenclature is referring to the pattern of execution that looks like this:

```shell
C# -->[calls]--> C API -->[implemented by]--> Rust
```

Note that the C API really involves no _actual_ C code - it's just a set of C function stubs that is backed by Rust `extern "C"` functions.

## C# function stubs

When you compile the Rust codebase herein using `cargo build`, a custom build script will execute to generate a C header file called `hyperlight_capi.h` in `src/hyperlight_capi/include`. This code is generated by [cbindgen](https://github.com/eqrion/cbindgen) and you can see how it works in our [build.rs file](https://github.com/deislabs/hyperlight/blob/main/src/hyperlight_host/build.rs).

Since we generate a standard header file, you can write C code that `#include`s that header file and links to the resulting dynamic library, and effectively call Rust from C.

In C#, things are not as simple, though, because C# doesn't know about or understand C header files. Currently, you have to essentially write your own version of the header file in C#. We call these C# "stubs".

>Note: we eventually plan to auto-generate these stubs. See [#180](https://github.com/deislabs/hyperlight/issues/180) and [#181](https://github.com/deislabs/hyperlight/issues/181) for more details).

The way to write these stubs is to put some `private static extern` functions inside a class somewhere, and annotate them to tell the .Net runtime that you intend for these functions to be provided by a native shared library (DLL, in .Net terms). Here's an example of such a function:

```csharp
[DllImport("hyperlight_host", SetLastError = false, ExactSpelling = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
[return: MarshalAs(UnmanagedType.U1)]
private static extern bool handle_is_empty(NativeHandle handle);
```

## Wrapping function stubs

Because C# function stubs deal with mostly low-level types (`NativeHandle`, in the above example stub, is an `IntPtr`), it's usually a good idea to wrap them in a more "friendly" interface. Usually, such interfaces will have a few properties:

- The stubs will be `private`
- The same `class` that holds the stubs will have convenience wrappers
- If the `class` handles some data that needs to be "freed" (e.g. memory on the heap), it will implement `IDisposable` and automatically do the free operation in the `Dispose` method
- If the stubs deal with inconvenient or native-like types (like unsafe pointers, `IntPtr`, or slices of bytes instead of strings), the wrapper functions will expose more convenient types and do the conversions internally (e.g. accepting and returning strings, and converting to `byte[]` internally)

A great example of a wrapper is [Wrapper.Handle](https://github.com/deislabs/hyperlight/blob/main/src/Hyperlight/Wrapper/Handle.cs).

## Passing Strings from C# to Rust

C#, Rust and C strings are incompatibly different from each other, so the easiest course of action is to represent everything as a sequence of `byte`s with a `NUL` character at the end (i.e. `\0`).

In other words, in C# and Rust, we should represent any String as a C string to prepare to pass it to C (in the C# case) or consume it from C (in the Rust case).

Do this with code roughly equivalent to this in C#:

```csharp
// assumption: msg is a C# String type
// first, convert the String to an array of bytes
var byteArr = Encoding.Default.GetBytes(msg);
// next, extend the array by one byte andappend the
// NULL byte at the end
Array.Resize(ref byteArr, byteArr.Length + 1);
byteArr[barr.Length - 1] = (byte)'\0';
// now, pass the byte array to the external C function
var result = some_external_function(byteArr)
```

If you do this, then your Rust function should expect to receive a standard C-style string. In other words, your Rust function can expect a `const char*` that points to the first `char` in the string, and the string will be `NUL` terminated.

## Returning strings to C# from Rust

While passing a string from C# to Rust has several steps (illustrated in the previous section), returning a string from Rust is simpler. As long as the Rust code returns a standard C-style string (a `char*` or `const char*` with a single `NUL` character at the end), then C# will do the "right thing" if you create a stub that looks like this:

```csharp
[DllImport("hyperlight_host", SetLastError = false, ExactSpelling = true, CharSet = CharSet.Unicode)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
[return: MarshalAs(UnmanagedType.LPUTF8Str)]
private static extern String handle_get_error_message(
    NativeContext ctx,
    NativeHandle handle
);
```

Note the `[return: MarshalAs(UnmanagedType.LPUTF8Str)]` annotation. This tells C# to treat the C-style string that Rust returned as a pointer to a UTF-8 string, and present it as a standard C# `string` type. 

### Stubs that have string parameters

We've seen that, if you want to _pass_ a string to Rust, you have to decompose it to a simple `byte[]` (byte array, in C# nomenclature) and pass that instead.

When you build the C# stub for the function that accepts the string, annotate the `byte[]` parameter with `[In]` like the second parameter in this example:

```csharp
[DllImport("hyperlight_host", SetLastError = false, ExactSpelling = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
private static extern NativeHandle handle_new_err(
    NativeContext ctx,
    [In] byte[] errMsg
);
```

## Returning `bool` from Rust

Rust (and C) represents booleans differently than C# does, so we have to ensure that, if Rust returns a `bool`, we tell C# to read that value properly with a `Marshal` attribute, like this:

```csharp
[DllImport("hyperlight_host", SetLastError = false, ExactSpelling = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
[return: MarshalAs(UnmanagedType.U1)]
public static extern bool handle_free(
    NativeContext context,
    NativeHandle handle
);
```

The `UnmanagedType.U1` tells C# to treat the returned `bool` as 1-byte unsigned integer, which is compatible with the Rust and C implementation.
