# Notes on C# <--> Rust interop

> Note: Maintaining the C# Hyperlight host library is no longer priority, and we encourage developers to use the Rust Hyperlight library directly.

This section contains notes and learnings on how to get C# and Rust to play well together. Since we primarily call Rust from C# in this codebase, the notes here mostly cover that task, rather than calling C# from Rust or anything else.

## General

Generally speaking, C# code cannot directly call a Rust function. Instead, it has to call a C function interface, and Rust has to implement that C function interface. In practice, the effect is the same.

In this document, you'll see lots of mentions of C# calling, or passing data to, C, and Rust consuming or receiving data from C. This nomenclature is referring to the pattern of execution that looks like this:

```shell
C# -->[calls]--> C API -->[implemented by]--> Rust
```

Note that the C API really involves no _actual_ C code - it's just a set of C function stubs that is backed by Rust `extern "C"` functions.

## C# function stubs

When you compile the Rust codebase herein using `cargo build`, a custom build script will execute to generate a C header file called `hyperlight_capi.h` in `src/hyperlight_capi/include`. This code is generated by [cbindgen,](https://github.com/eqrion/cbindgen) and you can see how it works in [hyperlight_host's build.rs file](https://github.com/deislabs/hyperlight/blob/main/src/hyperlight_host/build.rs).

Since we generate a standard header file, you can write C code that `#include`s that header file and links to the resulting dynamic library, and effectively call Rust from C.

In C#, things are not as simple, though, because C# doesn't know about or understand C header files. Currently, you have to essentially write your own version of the header file in C#. We call these C# "stubs".

> Note: we eventually plan to auto-generate these stubs. See [#180](https://github.com/deislabs/hyperlight/issues/180) and [#181](https://github.com/deislabs/hyperlight/issues/181) for more details.

The way to write these stubs is to put some `private static extern` functions inside a class somewhere, and annotate them to tell the .NET runtime that you intend for these functions to be provided by a native shared library (DLL, in .NET terms). Here's an example of such a function:

```csharp
[DllImport("hyperlight_host", SetLastError = false, ExactSpelling = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
[return: MarshalAs(UnmanagedType.U1)]
private static extern bool handle_is_empty(NativeHandle handle);
```

## Wrapping function stubs

Because C# function stubs deal with mostly low-level types (`NativeHandle`, in the above example stub, is an `IntPtr`), it's usually a good idea to wrap them in a more "friendly" interface. Usually, such interfaces will have a few properties:

- The stubs will be `private`
- The same `class` that holds the stubs will have convenience wrappers
- If the `class` handles some data that needs to be "freed" (e.g. memory on the heap), it will implement `IDisposable` and automatically do the free operation in the `Dispose` method
- If the stubs deal with inconvenient or native-like types (like unsafe pointers, `IntPtr`, or slices of bytes instead of strings), the wrapper functions will expose more convenient types and do the conversions internally (e.g. accepting and returning strings, and converting to `byte[]` internally)

A great example of a wrapper is [Wrapper.Handle](https://github.com/deislabs/hyperlight/blob/main/src/Hyperlight/Wrapper/Handle.cs).

## Passing Strings from C# to Rust

C#, Rust and C strings are incompatibly different from each other, so the easiest course of action is to represent everything as a sequence of `byte`s with a `NUL` character at the end (i.e. `\0`).

In other words, in C# and Rust, we should represent any String as a C string to prepare to pass it to C (in the C# case) or consume it from C (in the Rust case).

Do this with code roughly equivalent to this in C#:

```csharp
// assumption: msg is a C# String type
// first, convert the String to an array of bytes
var byteArr = Encoding.Default.GetBytes(msg);
// next, extend the array by one byte andappend the
// NULL byte at the end
Array.Resize(ref byteArr, byteArr.Length + 1);
byteArr[barr.Length - 1] = (byte)'\0';
// now, pass the byte array to the external C function
var result = some_external_function(byteArr)
```

If you do this, then your Rust function should expect to receive a standard C-style string. In other words, your Rust function can expect a `const char*` that points to the first `char` in the string, and the string will be `NUL` terminated.

## Returning strings to C# from Rust

While passing a string from C# to Rust has several steps (illustrated in the previous section), returning a string from Rust is simpler. As long as the Rust code returns a standard C-style string (a `char*` or `const char*` with a single `NUL` character at the end), then C# will do the "right thing" if you create a stub that looks like this:

```csharp
[DllImport("hyperlight_host", SetLastError = false, ExactSpelling = true, CharSet = CharSet.Unicode)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
[return: MarshalAs(UnmanagedType.LPUTF8Str)]
private static extern String handle_get_error_message(
    NativeContext ctx,
    NativeHandle handle
);
```

Note the `[return: MarshalAs(UnmanagedType.LPUTF8Str)]` annotation. This tells C# to treat the C-style string that Rust returned as a pointer to a UTF-8 string, and present it as a standard C# `string` type.

### Stubs that have string parameters

We've seen that, if you want to _pass_ a string to Rust, you have to decompose it to a simple `byte[]` (byte array, in C# nomenclature) and pass that instead.

When you build the C# stub for the function that accepts the string, annotate the `byte[]` parameter with `[In]` like the second parameter in this example:

```csharp
[DllImport("hyperlight_host", SetLastError = false, ExactSpelling = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
private static extern NativeHandle handle_new_err(
    NativeContext ctx,
    [In] byte[] errMsg
);
```

## Returning `bool` from Rust

Rust (and C) represents booleans differently than C# does, so we have to ensure that, if Rust returns a `bool`, we tell C# to read that value properly with a `Marshal` attribute, like this:

```csharp
[DllImport("hyperlight_host", SetLastError = false, ExactSpelling = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
[return: MarshalAs(UnmanagedType.U1)]
public static extern bool handle_free(
    NativeContext context,
    NativeHandle handle
);
```

The `UnmanagedType.U1` tells C# to treat the returned `bool` as 1-byte unsigned integer, which is compatible with the Rust and C implementation.

## Learnings

This section contains learnings we've gained over the course of building this project.

Generally speaking, it's important to keep track of our learnings, but since we're doing some things in this project that haven't been done much before, it's especially important to keep track of both what we've learned along the way, and how we've solved some of these new-ish problems.

Now, all calls from C# to Rust and vice-versa happen via standard C. Most of the time, Rust will be exposing a C API, and C# will call it, but in some cases, Rust will call back into C#. Neither area has been done much, but the latter case is generally more error-prone and has less prior art than the former.

### No pointers

First and foremost, it's important to not pass pointers across any language boundary. In practice, this means the `hyperlight_capi.h` header file should not contain any pointers.

> There is one big exception to this rule (see the "Context pointers" section below). There may be others, but don't make any of these exceptions unless you have a good reason and know what you're doing.

You of course still need to reference memory on the heap, and we've created the following Rust types to facilitate that functionality:

- `Context` - the data structure that holds memory in a (somewhat) concurrency-safe manner
- `Handle` - a safe(er than raw pointer) reference to some memory in a `Context`

Almost all C functions exposed by Rust (hereafter, the "Hyperlight C API") take a `Context*` and one or more `Handle`s. Generally speaking, the first thing these API functions do is look in the `Context` for the memory the `Handle` references. This is how we "dereference" a `Handle`.

#### `Context` pointers

As mentioned previously, the first parameter that most Hyperlight API functions take is a `Context*`, which is a pointer. This is the primary, and generally only, exception to the "no pointers" rule.

### Standard function signatures

Since most Rust functions take a `Context*` as their first parameter, and has to dereference that pointer parameter, those functions must be marked `unsafe`. Mark the entire function `unsafe` rather than just creating an `unsafe` block inside the function.

The standard function signature should look approximately like this:

```rust
#[no_mangle]
pub unsafe extern "C" fn ${FUNC_NAME}(
    ctx: *mut Context,
    hdl: Handle,
    [${OTHER_PARAM_1}, ...]
) -> Handle {
  validate_context!(ctx);
```

Since the function is marked `unsafe` due to the `*mut Context` parameter, the linter will require a `# Safety` section in the documentation comment. That section should _at least_ describe the requirements of the `ctx` parameter:

```markdown
/// # Safety
///
/// You must call this function with a `Context*` that has been:
///
/// - Created with `context_new`
/// - Not yet freed with `context_free`
/// - Not modified, except by calling functions in the Hyperlight C API
```

If there are other memory (or other safety, validity, etc...) requirements, they should go in this comment block as well.

A few more notes on this function signature:

- A `hyperlight_capi.h` header file will automatically be generated by [cbindgen](https://github.com/eqrion/cbindgen) every time you run `cargo build`
  - Find the file in `src/hyperlight_capi/include/hyperlight_capi.h`
- the `*mut Context` parameter gets translated to `Context*` in C code by cbindgen, and `*const Context` gets translated to `const Context*`
  - Most of the time, `*mut Context` will be required, but try to use `*const Context` wherever possible

### Calling Rust from C# code

The previous sections detailed how to create C APIs from Rust, which is most of the work involved to call Rust from C#. The C# side involves the following work:

- Create C# "stubs"
- Call C# "stubs"

A C# "stub" is a function declaration, written in C# syntax, for an external function (common .Net terminology for this is a "P/Invoke function"). Such a function commonly looks like this:

```csharp
[DllImport("hyperlight_capi", SetLastError = false, ExactSpelling = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
private static extern NativeHandle ${FUNC_NAME}(
    NativeContext context,
    NativeHandle hdl,
    [${OTHER_PARAM_1}, ...]
)
```

These function stubs need to match the Rust `extern "C"` function you intend to call. It's currently a manual process to create and maintain these stubs, which can be a bit tedious. Below is an incomplete guide for translating from Rust style, syntax and types to C#:

- `*mut Context` or `*const Context` => `Hyperlight.Wrapper.NativeContext`
- `Handle` => `Hyperlight.Wrapper.NativeHandle`
- `bool` => `bool`, with the following caveats:
  - If you intend to return a `bool`, add this annotation above the function: `[return: MarshalAs(UnmanagedType.U1)]`
  - If there is a `bool` parameter, it should also be marked as an `UnmanagedType.U1`
- Any pointer type besides `Context*` => `IntPtr`

## Calling C# from Rust

This area is less explored than the previous.

Generally speaking, Rust code should:

- Provide an API to store an `extern "C" fn` in a `Context` and return a `Handle` that references it
- Provide an API that is able to call the function given a `Context`, `Handle` and some parameters

And C# code should:

- Create stubs that use an `IntPtr` for the `extern "C" fn`
- Use `Marshal.GetFunctionPointerForDelegate` to convert a `delegate` (of which an `Action` is an implementation) to an `IntPtr`, which can then be passed to the stub
