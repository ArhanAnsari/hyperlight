# Development Notes

This document contains learnings we've gained over the course of building this project.

Generally speaking, it's important to keep track of our learnings, but since we're doing some things in this project that haven't been done much before, it's especially important to keep track of both what we've learned along the way, and how we've solve some of these new-ish problems.

## C# <--> Rust Interop

All calls from C# to Rust and vice-versa happen via standard C. Most of the time, Rust will be exposing a C API, and C# will call it, but in some cases, Rust will call back into C#. Neither area has been done much, but the latter case is generally more error-prone and has less prior art than the former.

### No pointers

First and foremost, it's important to not pass pointers across the language boundary. In practice, this means the `hyperlight_capi.h` header file should not contain any pointers.

>There is one big exception to this rule (see the "Context pointers" section below). There may be others, but don't make any of these exceptions unless you have a really good reason and know what you're doing.

You of course still need to reference memory on the heap, and we've created the following Rust types to facilitate that functionality:

- `Context` - the data structure that holds memory in a (somewhat) concurrency-safe manner
- `Handle` - a safe(er than raw pointer) reference to some memory in a `Context`

Almost all C functions exposed by Rust (hereafer, the "Hyperlight C API") take a `Context*` and one or more `Handle`s. Generally speaking, the first thing these API functions do is look in the `Context` for the memory the `Handle` references. This is how we "dereference" a `Handle`.

#### `Context` pointers

As mentioned previously, the first parameter that most Hyperlight API functions take is a `Context*`, which is a pointer. This is the primary, and generally only, exception to the "no pointers" rule.

### Standard function signatures

Since most Rust functions take a `Context*` as their first parameter, and has to dereference that pointer parameter, those functions must be marked `unsafe`. Mark the entire function `unsafe` rather than just creating an `unsafe` block inside the function.

The standard function signature should look approximately like this:

```rust
#[no_mangle]
pub unsafe extern "C" fn ${FUNC_NAME}(
    ctx: *mut Context,
    hdl: Handle,
    [${OTHER_PARAM_1}, ...]
) -> Handle {
  validate_context!(ctx);
```

Since the function is marked `unsafe` due to the `*mut Context` parameter, the linter will require a `# Safety` section in the documentation comment. That section should _at least_ describe the requirements of the `ctx` parameter:

```markdown
/// # Safety
///
/// You must call this function with a `Context*` that has been:
///
/// - Created with `context_new`
/// - Not yet freed with `context_free`
/// - Not modified, except by calling functions in the Hyperlight C API
```

If there are other memory (or other safety, validity, etc...) requirements, they should go in this comment block as well.

A few more notes on this function signature:

- A `hyperlight_capi.h` header file will automatically be generated by [cbindgen](https://github.com/eqrion/cbindgen) every time you run `cargo build`
  - Find the file in `src/hyperlight_capi/include/hyperlight_capi.h`
- the `*mut Context` parameter gets translated to `Context*` in C code by cbindgen, and `*const Context` gets translated to `const Context*`
  - Most of the time, `*mut Context` will be required, but try to use `*const Context` wherever possible

### Calling Rust from C# code

The previous sections detailed how to create C APIs from Rust, which is most of the work involved to call Rust from C#. The C# side involves the following work:

- Create C# "stubs"
- Call C# "stubs"

A C# "stub" is a function declaration, written in C# syntax, for an external function (common .Net terminology for this is a "P/Invoke function"). Such a function commonly looks like this:

```csharp
[DllImport("hyperlight_capi", SetLastError = false, ExactSpelling = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
private static extern NativeHandle ${FUNC_NAME}(
    NativeContext context,
    NativeHandle hdl,
    [${OTHER_PARAM_1}, ...]
)
```

These function stubs need to match the Rust `extern "C"` function you intend to call. It's currently a manual process to create and maintain these stubs, which can be a bit tedious. Below is an incomplete guide for translating from Rust style, syntax and types to C#:

- `*mut Context` or `*const Context` => `Hyperlight.Wrapper.NativeContext`
- `Handle` => `Hyperlight.Wrapper.NativeHandle`
- `bool` => `bool`, with the following caveats:
  - If you intend to return a `bool`, add this annotation above the function: `[return: MarshalAs(UnmanagedType.U1)]`
  - If there is a `bool` parameter, it should also be marked as an `UnmanagedType.U1`
- Any pointer type besides `Context*` => `IntPtr`

## Calling C# from Rust

This area is less explored than the previous.

Generally speaking, Rust code should:

- Provide an API to store an `extern "C" fn` in a `Context` and return a `Handle` that references it
- Provide an API that is able to call the function given a `Context`, `Handle` and some parameters

... and C# code should:

- Create stubs that use an `IntPtr` for the `extern "C" fn`
- Use `Marshal.GetFunctionPointerForDelegate` to convert a `delegate` (of which an `Action` is an implementation) to an `IntPtr`, which can then be passed to the stub
